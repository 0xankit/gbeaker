{"version":3,"file":"index.umd.min.js","sources":["../src/account.ts","../src/utils.ts","../src/contract.ts"],"sourcesContent":["import { stringToPath } from '@cosmjs/crypto';\nimport type { HttpEndpoint } from '@cosmjs/tendermint-rpc';\nimport {\n  Coin,\n  GasPrice,\n  Secp256k1HdWallet,\n  SigningCosmWasmClient,\n} from 'cosmwasm';\n\ntype Config = {\n  global: {\n    account_prefix: string;\n    derivation_path: string;\n    networks: { [x: string]: { rpc_endpoint: string | HttpEndpoint } };\n    gas_price: string;\n    accounts: Record<string, { mnemonic: string }>;\n  };\n};\n\nexport type Account = {\n  signingClient: SigningCosmWasmClient;\n  wallet: Secp256k1HdWallet;\n  getBalance: (denom: string) => Promise<Coin>;\n};\n\nexport const fromMnemonic = async (\n  conf: Config,\n  network: string | number,\n  mnemonic: string,\n): Promise<Account> => {\n  if (typeof conf.global.account_prefix !== 'string') {\n    throw Error('`account_prefix` must be string');\n  }\n\n  const options = {\n    prefix: conf.global.account_prefix,\n    hdPaths: [stringToPath(conf.global.derivation_path)],\n  };\n  const wallet = await Secp256k1HdWallet.fromMnemonic(mnemonic, options);\n\n  const networkInfo = conf.global.networks[network];\n  if (!networkInfo) {\n    throw Error(`network info for ${network} not found in the config`);\n  }\n\n  const signingClient = await SigningCosmWasmClient.connectWithSigner(\n    networkInfo.rpc_endpoint,\n    wallet,\n    { gasPrice: GasPrice.fromString(conf.global.gas_price) },\n  );\n  return {\n    signingClient,\n    wallet,\n    async getBalance(denom) {\n      const accounts = await wallet.getAccounts();\n      const address = accounts[0]?.address;\n\n      if (!address) {\n        throw Error(`No account not found from: ${accounts}`);\n      }\n\n      return await signingClient.getBalance(address, denom);\n    },\n  };\n};\n\nexport const getAccounts = async (conf: Config, network: string) => {\n  const accountName = Object.keys(conf.global.accounts);\n  const account = await Promise.all(\n    Object.values(conf.global.accounts).map((a) =>\n      fromMnemonic(conf, network, a.mnemonic),\n    ),\n  );\n\n  return Object.fromEntries(accountName.map((name, i) => [name, account[i]]));\n};\n","/* eslint-disable */\n\nconst id = <T>(x: T) => x;\n\nexport const mapObject = (\n  o: Record<string, unknown>,\n  f: Function,\n  g: Function,\n): Record<string, unknown> =>\n  Object.fromEntries(Object.entries(o).map(([k, v]) => [f(k), g(v)]));\n\nexport const mapValues = (o: Record<string, unknown>, g: Function) =>\n  mapObject(o, id, g);\n\nexport const extendWith =\n  (properties: Record<string, unknown>) =>\n  (context: Record<string, unknown>) => {\n    Object.entries(properties).forEach(([k, v]) => {\n      // @ts-ignore\n      context[k] = v;\n      // Object.defineProperty(context, k, {\n      //   configurable: true,\n      //   enumerable: true,\n      //   value: v,\n      // });\n    });\n  };\n","import type { CosmWasmClient, StdFee } from 'cosmwasm';\nimport type { Account } from './account';\nimport { mapObject, mapValues } from './utils';\n\ntype Msg = Record<string, unknown>;\nexport const getContracts = (\n  client: CosmWasmClient,\n  state: Record<string, unknown>,\n) => {\n  const getContract = (address: string) => ({\n    address,\n    async getInfo() {\n      return client.getContract(address);\n    },\n    async getCode() {\n      return client.getCodeDetails((await this.getInfo()).codeId);\n    },\n    async query(qmsg: Msg) {\n      return await client.queryContractSmart(address, qmsg);\n    },\n    execute(\n      xmsg: Msg,\n      senderAddress: string | null,\n      fee: number | 'auto' | StdFee = 'auto',\n    ) {\n      return {\n        async by(account: Account) {\n          const _senderAddress =\n            senderAddress || (await account.wallet.getAccounts())[0]?.address;\n\n          if (!_senderAddress) {\n            throw Error('Unable to get sender address');\n          }\n\n          return await account.signingClient.execute(\n            _senderAddress,\n            address,\n            xmsg,\n            fee,\n          );\n        },\n      };\n    },\n  });\n\n  return mapValues(\n    state,\n    (contractInfo: { addresses: Record<string, Record<string, string>> }) => {\n      const addresses = contractInfo.addresses;\n      const prefixLabel = (label: string) => `$${label}`;\n      let contracts = mapObject(addresses, prefixLabel, getContract);\n\n      if (typeof contracts['$default'] === 'object' && contracts['$default']) {\n        contracts = {\n          ...contracts,\n          ...contracts['$default'],\n        };\n      }\n      return contracts;\n    },\n  );\n};\n"],"names":["id","x","mapObject","o","f","g","Object","fromEntries","entries","map","_a","k","v","properties","context","forEach","conf","network","__awaiter","accountName","keys","global","accounts","Promise","all","values","a","mnemonic","account_prefix","Error","options","prefix","hdPaths","stringToPath","derivation_path","Secp256k1HdWallet","fromMnemonic","wallet","sent","networkInfo","networks","concat","SigningCosmWasmClient","connectWithSigner","rpc_endpoint","gasPrice","GasPrice","fromString","gas_price","signingClient","getBalance","denom","getAccounts","_b","address","account","name","i","client","state","getContract","getInfo","getCode","getCodeDetails","this","_c","codeId","query","qmsg","queryContractSmart","execute","xmsg","senderAddress","fee","by","_senderAddress","contractInfo","addresses","contracts","label","__assign"],"mappings":"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"}